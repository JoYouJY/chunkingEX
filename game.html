<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DEMO FARPG</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="TemplateData/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="TemplateData/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="TemplateData/favicon-16x16.png" />
    <link rel="stylesheet" href="TemplateData/style.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.9.2/ethers.umd.js"></script>
    <meta name="theme-color" content="#000000" />
  </head>

  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    #unity-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    /* Hide scrollbar for Chrome, Safari and Opera */
    ::-webkit-scrollbar {
      display: none;
    }
    /* Hide scrollbar for IE, Edge and Firefox */
    html {
      -ms-overflow-style: none; /* IE and Edge */
      scrollbar-width: none;    /* Firefox */
    }
    #unity-canvas {
      background-color: rgba(0, 0, 0, 0.5);
    }
  </style>

  <body style="background-color: #000000;">
    <!-- A separate module script for index.js -->
    <script type="module" src="./index.js"></script>

    <script>
      function clearCache() {
        o =
          window.indexedDB ||
          window.mozIndexedDB ||
          window.webkitIndexedDB ||
          window.msIndexedDB;
        var t = {
          name: "UnityCache",
          version: 3
        };
        o.deleteDatabase(t.name);
        location.reload();
        //alert("Cache cleared successfully!");
      }
    </script>

    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas" width="1920" height="1080"></canvas>

      <div id="unity-loading-bar" style="background: rgba(0, 0, 0, 0);">
        <div
          class="video-container"
          style="
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0);
          "
        >
          <video
            src="TemplateData/Characters moving L loading.mp4"
            autoplay
            loop
            muted
          ></video>
        </div>

        <div class="progress">
          <div class="bar">
            <div class="progress-value"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      var chains = "fantom";

      var container = document.querySelector("#unity-container");
      var canvas = document.querySelector("#unity-canvas");
      var loadingBar = document.querySelector("#unity-loading-bar");
      var warningBanner = document.querySelector("#unity-warning");
      const ASPECT_RATIO = 16 / 9;

      function resizeCanvas() {
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var windowRatio = windowWidth / windowHeight;

        var newWidth, newHeight;

        if (windowRatio > ASPECT_RATIO) {
          // Window is wider than the target aspect ratio
          newHeight = windowHeight;
          newWidth = newHeight * ASPECT_RATIO;
        } else {
          // Window is taller than the target aspect ratio
          newWidth = windowWidth;
          newHeight = newWidth / ASPECT_RATIO;
        }

        canvas.style.width = newWidth + "px";
        canvas.style.height = newHeight + "px";
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas(); // Call once to set initial size
      // Call resizeCanvas again after 2 seconds
      setTimeout(resizeCanvas, 2000);
    </script>

    <script>
      //##################  bind #############
      async function loadAndCombineChunks(chunkUrls) {
        // Artificial 7-second delay for demonstration
        //console.log("###########################5 second passing");
        //await new Promise((resolve) => setTimeout(resolve, 5000));

        // Fetch all chunks
        const chunkPromises = chunkUrls.map((url) =>
          fetch(url).then((response) => {
            if (!response.ok) {
              throw new Error(`Failed to load chunk: ${url}`);
            }
            return response.arrayBuffer(); // Load as binary data
          })
        );

        // Wait for all chunks to be downloaded
        const chunks = await Promise.all(chunkPromises);

        // Combine chunks into a single ArrayBuffer
        const totalSize = chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
        const combinedBuffer = new Uint8Array(totalSize);

        let offset = 0;
        for (const chunk of chunks) {
          combinedBuffer.set(new Uint8Array(chunk), offset);
          offset += chunk.byteLength;
        }

        // Return the combined buffer as a Blob URL
        return URL.createObjectURL(
          new Blob([combinedBuffer], { type: "application/octet-stream" })
        );
      }
      //######################################
    </script>

    <script>
      const isMobile = /iPhone|iPod/i.test(navigator.userAgent);

      if (isMobile) {
        // Create a div element for the unsupported message
        const messageDiv = document.createElement("div");

        // Set the message text
        messageDiv.innerText =
          "Supporting Android and Windows now, iPhone coming soon.";

        // Style the message (optional)
        messageDiv.style.position = "fixed";
        messageDiv.style.top = "50%";
        messageDiv.style.left = "50%";
        messageDiv.style.transform = "translate(-50%, -50%)";
        messageDiv.style.padding = "20px";
        messageDiv.style.backgroundColor = "#234567";
        messageDiv.style.color = "yellow";
        messageDiv.style.zIndex = "1000";
        messageDiv.style.borderRadius = "5px";
        messageDiv.style.textAlign = "center";

        // Append the message to the body
        document.body.appendChild(messageDiv);
      } else {
        var container = document.querySelector("#unity-container");
        var canvas = document.querySelector("#unity-canvas");
        var loadingBar = document.querySelector("#unity-loading-bar");
        var warningBanner = document.querySelector("#unity-warning");
        const progressbar = document.querySelector(".progress");

        // Wrap everything in an async IIFE to await chunk loading
        (async () => {
          // Show loading bar and running
          loadingBar.style.display = "block";
          let combinedDataUrl;
          try {
            // Adjust or add more chunks if needed
            const chunkUrls = [
              "Build/build.data.01",
              "Build/build.data.02",
              "Build/build.data.03",
              "Build/build.data.04",
              "Build/build.data.05",
              "Build/build.data.06",
              "Build/build.data.07",
              "Build/build.data.08",
              "Build/build.data.09",
              "Build/build.data.10",
              "Build/build.data.11",
              "Build/build.data.12",
              "Build/build.data.13",
              "Build/build.data.14",
              "Build/build.data.15",
              "Build/build.data.16",
              "Build/build.data.17",
              "Build/build.data.18",
              "Build/build.data.19"
            ];

            combinedDataUrl = await loadAndCombineChunks(chunkUrls);
            console.log("Combined build.data URL:", combinedDataUrl);
          } catch (error) {
            console.error("Error combining chunks:", error);
          }

          // Show a banner for warnings/errors
          function unityShowBanner(msg, type) {
            function updateBannerVisibility() {
              warningBanner.style.display = warningBanner.children.length
                ? "block"
                : "none";
            }

            var div = document.createElement("div");
            div.innerHTML = msg;
            warningBanner.appendChild(div);

            if (type == "error") {
              div.style = "background: red; padding: 10px;";
            } else {
              if (type == "warning") {
                div.style = "background: yellow; padding: 10px;";
              }
              setTimeout(function () {
                warningBanner.removeChild(div);
                updateBannerVisibility();
              }, 5000);
            }
            updateBannerVisibility();
          }

          var buildUrl = "Build";
          var loaderUrl = buildUrl + "/Build.loader.js";
        
          var config = {
            // We replace the old single dataUrl with our combinedDataUrl
            // dataUrl: buildUrl + "/Build.data",
            dataUrl: combinedDataUrl,
            frameworkUrl: buildUrl + "/Build.framework.js",
            codeUrl: buildUrl + "/Build.wasm",
            streamingAssetsUrl: "StreamingAssets",
            companyName: "Jojo Dream Studio",
            productName: "FateAdventureRPG",
            productVersion: "1.0.0",
            showBanner: unityShowBanner
          };
          
          var script = document.createElement("script");
          script.src = loaderUrl;

          script.onload = () => {
            createUnityInstance(canvas, config, (progress) => {
              // Update your CSS-based progress bar
              const value = Math.floor(progress * 100);
              progressbar.style.setProperty("--progress", `${value}%`);
            })
              .then((unityInstance) => {
                window.unityInstance = unityInstance;
                loadingBar.style.display = "none";
                setTimeout(switchToFantom, 3127);
                // Optionally: showInstallPrompt();
              })
              .catch((message) => {
                alert(message);
              });
          };

          document.body.appendChild(script);
        })(); // end of async block
      }
    </script>

    <script>
      let deferredPrompt;

      window.addEventListener("beforeinstallprompt", (e) => {
        e.preventDefault();
        deferredPrompt = e;
      });

      function showInstallPrompt() {
        if (deferredPrompt) {
          deferredPrompt.prompt();
          deferredPrompt.userChoice.then((choiceResult) => {
            if (choiceResult.outcome === "accepted") {
              canvas.style.display = "block"; // Hide the canvas
            } else {
              canvas.style.display = "block"; // Hide the canvas
            }
            deferredPrompt = null;
          });
        }
      }

      //-----------------------------version checking-------------------------------------------------
      async function checkForUpdate() {
        try {
          const currentVersion = await getCachedVersion(); // Get the version from the cache
          const latestVersion = await fetchLatestVersion(); // Fetch the latest version from the server

          // Compare versions, refresh if a new version is detected
          if (latestVersion && currentVersion && currentVersion !== latestVersion) {
            // Unregister all service workers
            if ("serviceWorker" in navigator) {
              const registrations = await navigator.serviceWorker.getRegistrations();
              for (let registration of registrations) {
                await registration.unregister(); // Unregister old service worker
              }
            }

            // Clear all caches
            const cacheNames = await caches.keys();
            await Promise.all(
              cacheNames.map((cacheName) => {
                return caches.delete(cacheName); // Delete each cache
              })
            );

            // Reload page to register the new service worker and fetch fresh content
            window.location.reload(true);
            window.location.href =
              window.location.href +
              (window.location.href.includes("?") ? "&" : "?") +
              "cache-bust=" +
              new Date().getTime();
          }
        } catch (error) {
          console.error("Error during version check:", error);
        }
      }

      // Function to fetch the latest version.json from the server
      async function fetchLatestVersion() {
        try {
          const response = await fetch("/version.json", { cache: "no-store" });
          const data = await response.json();
          return data.version;
        } catch (error) {
          console.error("Error fetching latest version:", error);
          return null;
        }
      }

      // Function to get the version cached by the service worker
      async function getCachedVersion() {
        try {
          const CACHE_NAME = "fa-rpg-cache-v1"; // Ensure the same cache name is used here too!
          const cache = await caches.open(CACHE_NAME); // Open the cache
          const cachedResponse = await cache.match("/version.json"); // Look for version.json in cache

          if (cachedResponse) {
            const data = await cachedResponse.json();
            return data.version; // Return the version key
          } else {
            console.warn("version.json not found in cache"); // Warn if not found in cache
            return null;
          }
        } catch (error) {
          console.error("Error fetching cached version:", error);
          return null;
        }
      }

      // Call this function periodically or on page load to check for updates
      setInterval(checkForUpdate, 600000); // Check every 60 minutes

      // Delay the execution of checkForUpdate by 3 seconds after the page is loaded
      window.addEventListener("load", () => {
        setTimeout(() => {
          checkForUpdate();
        }, 5000); // 3000 milliseconds = 3 seconds
      });

      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("/service-worker.js")
            .then((registration) => {
              // ServiceWorker registered
            })
            .catch((error) => {
              // ServiceWorker registration failed
            });
        });
      }
      //----------------------------------------------------------------------

    </script>
  </body>
</html>
